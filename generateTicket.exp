#!/usr/bin/expect -f
set ticketName [lindex $argv 0]
set thisScriptDir  [file dirname $argv0]
set shDir "$thisScriptDir/sh"


proc getPassword {} {
	stty -echo
	send_user -- "Git password: "
	expect_user -re "(.*)\n"
	send_user "\n"
	stty echo
	set password $expect_out(1,string)
	return $password
}

proc strlen s {
	set n 0
	foreach char [split $s ""] {incr n}
	return $n
} 

proc debugLog { debugMessage } {
	set message "EXPECT: $debugMessage"
	puts $message
}

proc cleanUpOnFail { shDir } {
	debugLog "There was an error. Attempting automatic cleanup";
	spawn bash $shDir/cleanUpOnFailAndInform.sh
		expect {
			"cleaned up. back to dev." {
				debugLog "Clean up successful. Please try generating a ticket again"		
			}
			default {
    			debugLog "Could not clean automatically. CLEAN UP MANUALLY."
			}
		}
        exit
}

proc checkoutDevAndPull { shDir password } {
    spawn bash $shDir/gitPullAndInform.sh
        expect {
            "Password for" {
                send "$password\r"; exp_continue
            }
			"fatal" {
				wait
				exp_close -i $spawn_id
				debugLog "Wrong password. Try again."
				exit
			}
            "gitPullDone" {
                wait
                exp_close -i $spawn_id
            }
        }
}

proc cleanLocalProxyBranch { shDir thisScriptDir } {
    spawn bash $shDir/cleanProxyBranchAndInform.sh
        expect {
            "proxyBranchExp deleted" {
				debugLog "Ready for use"	
				 }
            default { debugLog "could not delete proxy branch" }
        }
}

proc deleteTmpFile { shDir thisScriptDir } {
	spawn bash $shDir/deleteTmpFileAndInform.sh 
        expect {
            "tmpFile" {
            }
            default {
                debugLog "Could not delete temp file. Do it manually"
            }
        }

	if {[file exists $thisScriptDir/config/TmpAutoCommit.flag]} {
	 	spawn bash $shDir/commitTmpFileDeletionAndInform.sh
	        expect {
	            "commited" {
	            }
	            default {
	                debugLog "Could not commit tmp file deletion. Do it manually"
	            }
	        }
	}
}

proc start { ticketName shDir thisScriptDir password } {

    checkoutDevAndPull $shDir $password

    spawn bash $shDir/checkoutLocalBranchAndInform.sh
        expect {
            "proxyBranchExp created" {
                wait
                exp_close -i $spawn_id
            }
        }

    spawn bash $shDir/generateCommit.sh $ticketName
        expect {
            "ticketGeneratingCommitDone" {
                wait
                exp_close -i $spawn_id
            }
        }

    spawn bash $shDir/pushAndCreateUpstreamTicket.sh
        expect {
            "fatal" {cleanUpOnFail $shDir}
            "Password for" {send "$password\r"; exp_continue}
            "Expect upstream ticket created" {
                    set expBuffer $expect_out(buffer)
                    wait
                    exp_close -i $spawn_id 
                }
        }

	set ticketNumber null;
	
	 if {[regexp {\-\-\>\s#([\d]*)\:} $expBuffer -> key value]} {
		   set ticketNumber $key
	 } else {
			debugLog "could not parse ticketNumber"
			cleanUpOnFail $shDir
	 }

     checkoutDevAndPull $shDir $password

     spawn bash $shDir/checkoutLocalTicketAndInform.sh $ticketNumber
        expect {
            "expTicketCheckedOut" {
            }
            default {
                debugLog "could not checkout local ticket. Do it manually"
            }
        }

	deleteTmpFile $shDir $thisScriptDir
    cleanLocalProxyBranch $shDir $thisScriptDir

}

proc areAllChangesCommited {} {
	spawn git status
		expect {
			"nothing to commit, working tree clean" {
				return 1
			}
			default  {
				return 0
			}
		}
} 

set argsLen [llength $argv]
if {$argsLen != 1} {
    debugLog "Usage { ticket generation message (ticket name) }"
	debugLog "Enter the ticket name between quotation marks. Ex. \"This is a valid message\""
} else {

	if {[file exists $thisScriptDir/config/CheckStatus.flag]} {
		set isEverythingCommited [areAllChangesCommited] 
		if {$isEverythingCommited < 1} {
			debugLog "There are uncommited changes. Please commit them before generating a ticket."
			exit;
		}
	}


	set commitMessageLen [strlen $ticketName]
	if {$commitMessageLen < 10 || $commitMessageLen > 100} {
		debugLog "The ticket generation message must be between 10 and 100 symbols long"
		exit;
	} 

	set password [getPassword]
   	start $ticketName $shDir $thisScriptDir $password
	
}
